// This file is intentionally without code.
// It's present so that service worker registration will work when serving from the 'app' directory.
// The version of service-worker.js that's present in the 'dist' directory is automatically
// generated by the 'generate-service-worker' gulp task, and contains code to precache resources.

/* Set up files that will always be cached */
const cacheName = "v1";
const cacheFiles = [
  './',
  'https://fonts.googleapis.com/css?family=Nunito',
  './index.html',
  './styles/main.css',
  './scripts/main.js'
];

self.addEventListener('install', function(e) {
  console.log('[ServiceWorker] Installed');

  e.waitUntil(
    caches.open(cacheName).then(function(cache) {
      console.log('[ServiceWorker] Caching cachefiles');
      return cache.addAll(cacheFiles);
    })
  );
});

self.addEventListener('activate', function(e) {
  console.log('[ServiceWorker] Activated');

  //iterate through the cache and clear out old cachefiles
  e.waitUntil(
    caches.keys().then(function(cacheNames) {
      return Promise.all(cacheNames.map(function(thisCacheName){
        if (thisCacheName !== cacheName) {
          console.log('[ServiceWorker] Removing Cached Files from ', thisCacheName);
          return caches.delete(thisCacheName);
        }
      }));
    })
  )
});

self.addEventListener('fetch', function(e) {
  console.log('[ServiceWorker] Fetching', e.request.url);
});

const fetchData = function(type) {
  const postRequestUrl = 'http://minseoalexkim.com/wp-json/wp/v2/posts';
  const tagsRequestUrl = 'http://minseoalexkim.com/wp-json/wp/v2/tags';

  let requestUrl = type === 'reviews' ? postRequestUrl : tagsRequestUrl;
  console.log('-------------', requestUrl);
  return fetch(requestUrl, {'mode': 'cors'});
};

const processRequest = function(response) {
  return new Promise(function(resolve, reject) {
    if (response.type === 'opaque') {
      console.log('Received a response, but it\'s opaque so can\'t examine it');
      // Do something with the response (i.e. cache it for offline support)
      console.log(response);
      return;
    }

    if (response.status !== 200) {
      console.log('Looks like there was a problem. Status Code: ', response.status);
      return;
    }

    // Examine the text in the response
    response.json().then(function(responseText) {
      resolve(responseText);
    });
  });
};

const processData = function(data) {

  // Filter for book reviews using categories( Category "36")
  let filteredData = data[0].filter(function(post) {
    return post.categories[0] === 36;
  });

  let tagMap = new Map();

  // create a map that maps tag id(number) with tag name
  data[1].forEach(function(tag) {
    tagMap.set(tag.id, tag.name);
  });

  // Map only the relevant properties
  const processedData = filteredData.map(function(post, index) {
    // Since the content of the post is in html format, we split it by newline and only take the first sentence of the post as preview text to show.
    let contentSplitted = post.content.rendered.split('\n');
    let preview = contentSplitted[0];

    let tagNameList = [];

    // Iterate over tags, getting tag name from each tag id using tagMap.
    for (let i = 0; i < post.tags.length; i++) {
      let tagName = tagMap.get(post.tags[i]);
      if (Boolean(tagName)) {
        tagNameList.push(tagName);
      }
    }

    return {
      date: post.date,
      title: post.title.rendered,
      previewText: preview,
      fullContent: post.content.rendered,
      image: post.better_featured_image.source_url,
      tags: tagNameList,
      index: index
    };
  });

  console.log(processedData);
  return processedData;
};

const reviewDataPromise = fetchData('reviews').then(processRequest);
const tagsDataPromise = fetchData('tags').then(processRequest);

Promise.all([reviewDataPromise, tagsDataPromise]).then(processData);
